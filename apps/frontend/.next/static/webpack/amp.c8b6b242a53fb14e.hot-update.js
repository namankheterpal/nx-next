"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "../../node_modules/next/dist/shared/lib/router/router.js":
/*!****************************************************************!*\
  !*** ../../node_modules/next/dist/shared/lib/router/router.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _regeneratorRuntime = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _defineProperty = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\n\nvar _slicedToArray = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _asyncToGenerator = __webpack_require__(/*! ../../node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js */ \"../../node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator.js\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) {\n    Object.defineProperty(target, name, {\n      enumerable: true,\n      get: all[name]\n    });\n  }\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"../../node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"../../node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"../../node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"../../node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"../../node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?d22b\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"../../node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"../../node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"../../node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"../../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"../../node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"../../node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"../../node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"../../node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"../../node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"../../node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"../../node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"../../node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"../../node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"../../node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n          case 2:\n            matchers = _context8.sent;\n\n            if (matchers) {\n              _context8.next = 5;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 5:\n            _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n            cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n            asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n            // where we can access more info such as headers, HttpOnly cookie, etc.\n\n            return _context8.abrupt(\"return\", matchers.some(function (m) {\n              return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n            }));\n\n          case 9:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = _slicedToArray(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = _slicedToArray(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _matchesMiddleware(options);\n\n          case 2:\n            matches = _context9.sent;\n\n            if (!(!matches || !options.fetchData)) {\n              _context9.next = 5;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", null);\n\n          case 5:\n            _context9.prev = 5;\n            _context9.next = 8;\n            return options.fetchData();\n\n          case 8:\n            data = _context9.sent;\n            _context9.next = 11;\n            return getMiddlewareData(data.dataHref, data.response, options);\n\n          case 11:\n            effect = _context9.sent;\n            return _context9.abrupt(\"return\", {\n              dataHref: data.dataHref,\n              json: data.json,\n              response: data.response,\n              text: data.text,\n              cacheKey: data.cacheKey,\n              effect: effect\n            });\n\n          case 15:\n            _context9.prev = 15;\n            _context9.t0 = _context9[\"catch\"](5);\n            return _context9.abrupt(\"return\", null);\n\n          case 18:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require = __webpack_require__(/*! ../../lib/bloom-filter */ \"../../node_modules/next/dist/shared/lib/bloom-filter/index.js\"),\n          BloomFilter = _require.BloomFilter;\n\n      var staticFilterData = {\"bitset\":{\"size\":24,\"content\":\"psoD\"},\"hashes\":7,\"size\":20};\n      var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (false) {}\n\n                matchesBflStatic = false;\n                matchesBflDynamic = false;\n                _i = 0, _arr = [as, resolvedAs];\n\n              case 4:\n                if (!(_i < _arr.length)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                curAs = _arr[_i];\n\n                if (!curAs) {\n                  _context.next = 32;\n                  break;\n                }\n\n                asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n                if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                  _context.next = 32;\n                  break;\n                }\n\n                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.has(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.has(asNoSlashLocale));\n                _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n              case 12:\n                if (!(_i2 < _arr2.length)) {\n                  _context.next = 27;\n                  break;\n                }\n\n                normalizedAS = _arr2[_i2];\n                // if any sub-path of as matches a dynamic filter path\n                // it should be hard navigated\n                curAsParts = normalizedAS.split(\"/\");\n                i = 0;\n\n              case 16:\n                if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                currentPart = curAsParts.slice(0, i).join(\"/\");\n\n                if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.has(currentPart)))) {\n                  _context.next = 21;\n                  break;\n                }\n\n                matchesBflDynamic = true;\n                return _context.abrupt(\"break\", 24);\n\n              case 21:\n                i++;\n                _context.next = 16;\n                break;\n\n              case 24:\n                _i2++;\n                _context.next = 12;\n                break;\n\n              case 27:\n                if (!(matchesBflStatic || matchesBflDynamic)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!skipNavigate) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 30:\n                handleHardNavigation({\n                  url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                  router: this\n                });\n                return _context.abrupt(\"return\", new Promise(function () {}));\n\n              case 32:\n                _i++;\n                _context.next = 4;\n                break;\n\n              case 35:\n                return _context.abrupt(\"return\", false);\n\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if ((0, _islocalurl.isLocalURL)(url)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: url,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 3:\n                // WARNING: `_h` is an internal option for handing Next.js client-side\n                // hydration. Your app should _never_ use this property. It may change at\n                // any time without notice.\n                isQueryUpdating = options._h === 1;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this._bfl(as, undefined, options.locale);\n\n              case 7:\n                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n                // marking the router ready until after the query is updated\n                // or a navigation has occurred\n\n                readyStateChange = this.isReady !== true;\n                this.isReady = true;\n                isSsr = this.isSsr;\n\n                if (!isQueryUpdating) {\n                  this.isSsr = false;\n                } // if a route transition is already in progress before\n                // the query updating is triggered ignore query updating\n\n\n                if (!(isQueryUpdating && this.clc)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n                prevLocale = nextState.locale;\n\n                if (true) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n                if (typeof options.locale === \"undefined\") {\n                  options.locale = nextState.locale;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n                localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n                if (localePathResult.detectedLocale) {\n                  nextState.locale = localePathResult.detectedLocale;\n                  parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                  as = (0, _formaturl.formatWithValidation)(parsedAs);\n                  url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n                }\n\n                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n                // moves this on its own due to the return\n\n                if (false) {}\n\n                if (!didNavigate) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 28:\n                // marking route changes as a navigation start entry\n                if (_utils.ST) {\n                  performance.mark(\"routeChange\");\n                }\n\n                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n                routeProps = {\n                  shallow: shallow\n                };\n\n                if (this._inFlightRoute && this.clc) {\n                  if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                  }\n\n                  this.clc();\n                  this.clc = null;\n                }\n\n                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                this._inFlightRoute = as;\n                localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n                // We should not proceed. We should only change the state.\n\n                if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                  _context2.next = 52;\n                  break;\n                }\n\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n                this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                  scroll: false\n                }));\n\n                if (scroll) {\n                  this.scrollToHash(cleanedAs);\n                }\n\n                _context2.prev = 41;\n                _context2.next = 44;\n                return this.set(nextState, this.components[nextState.route], null);\n\n              case 44:\n                _context2.next = 50;\n                break;\n\n              case 46:\n                _context2.prev = 46;\n                _context2.t0 = _context2[\"catch\"](41);\n\n                if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n                }\n\n                throw _context2.t0;\n\n              case 50:\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return _context2.abrupt(\"return\", true);\n\n              case 52:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n                // trigger hard navigation\n\n                if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                  _context2.next = 57;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 57:\n                _context2.prev = 57;\n                _context2.next = 60;\n                return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n              case 60:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                pages = _yield$Promise$all2[0];\n                rewrites = _yield$Promise$all2[1].__rewrites;\n                _context2.next = 70;\n                break;\n\n              case 66:\n                _context2.prev = 66;\n                _context2.t1 = _context2[\"catch\"](57);\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 70:\n                // If asked to change the current URL we should reload the current page\n                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                // We also need to set the method = replaceState always\n                // as this should not go into the history (That's how browsers work)\n                // We should compare the new asPath to the current asPath, not the url\n                if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                  method = \"replaceState\";\n                } // we need to resolve the as value using rewrites for dynamic SSG\n                // pages to allow building the data URL correctly\n\n\n                resolvedAs = as; // url and as should always be prefixed with basePath by this\n                // point by either next/link or router.push/replace so strip the\n                // basePath from the pathname to match the pages dir 1-to-1\n\n                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n                // middleware as the resolving will occur server-side\n\n                _context2.t2 = !options.shallow;\n\n                if (!_context2.t2) {\n                  _context2.next = 81;\n                  break;\n                }\n\n                _context2.next = 80;\n                return _matchesMiddleware({\n                  asPath: as,\n                  locale: nextState.locale,\n                  router: this\n                });\n\n              case 80:\n                _context2.t2 = _context2.sent;\n\n              case 81:\n                isMiddlewareMatch = _context2.t2;\n\n                if (isQueryUpdating && isMiddlewareMatch) {\n                  shouldResolveHref = false;\n                }\n\n                if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                  _context2.next = 96;\n                  break;\n                }\n\n                options._shouldResolveHref = true;\n\n                if (true) {\n                  _context2.next = 94;\n                  break;\n                }\n\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context2.next = 90;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", true);\n\n              case 90:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = rewritesResult.asPath;\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                _context2.next = 96;\n                break;\n\n              case 94:\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n                if (parsed.pathname !== pathname) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 96:\n                if ((0, _islocalurl.isLocalURL)(as)) {\n                  _context2.next = 101;\n                  break;\n                }\n\n                if (false) {}\n\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n              case 99:\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", false);\n\n              case 101:\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                routeMatch = false;\n\n                if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                  _context2.next = 119;\n                  break;\n                }\n\n                parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                asPathname = parsedAs.pathname;\n                routeRegex = (0, _routeregex.getRouteRegex)(route);\n                routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                shouldInterpolate = route === asPathname;\n                interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                  _context2.next = 118;\n                  break;\n                }\n\n                missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                  return !query[param] && !routeRegex.groups[param].optional;\n                });\n\n                if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                  _context2.next = 116;\n                  break;\n                }\n\n                if (true) {\n                  console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                }\n\n                throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n              case 116:\n                _context2.next = 119;\n                break;\n\n              case 118:\n                if (shouldInterpolate) {\n                  as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                  }));\n                } else {\n                  // Merge params into `query`, overwriting any specified in search\n                  Object.assign(query, routeMatch);\n                }\n\n              case 119:\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeStart\", as, routeProps);\n                }\n\n                isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n                _context2.prev = 121;\n                _context2.next = 124;\n                return this.getRouteInfo({\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: routeProps,\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  hasMiddleware: isMiddlewareMatch,\n                  unstable_skipClientCache: options.unstable_skipClientCache,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback,\n                  isMiddlewareRewrite: isMiddlewareRewrite\n                });\n\n              case 124:\n                routeInfo = _context2.sent;\n\n                if (!(!isQueryUpdating && !options.shallow)) {\n                  _context2.next = 128;\n                  break;\n                }\n\n                _context2.next = 128;\n                return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n              case 128:\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                  pathname = routeInfo.route || route;\n                  route = pathname;\n\n                  if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                  }\n\n                  cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                  if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach(function (key) {\n                      if (routeMatch && query[key] === routeMatch[key]) {\n                        delete query[key];\n                      }\n                    });\n                  }\n\n                  if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    rewriteAs = prefixedAs;\n\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                      rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n\n                    if (false) {}\n\n                    _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                    if (curRouteMatch) {\n                      Object.assign(query, curRouteMatch);\n                    }\n                  }\n                } // If the routeInfo brings a redirect we simply apply it.\n\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 136;\n                  break;\n                }\n\n                if (!(routeInfo.type === \"redirect-internal\")) {\n                  _context2.next = 134;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n              case 134:\n                handleHardNavigation({\n                  url: routeInfo.destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 136:\n                component = routeInfo.Component;\n\n                if (component && component.unstable_scriptLoader) {\n                  scripts = [].concat(component.unstable_scriptLoader());\n                  scripts.forEach(function (script) {\n                    (0, _script.handleClientScriptLoad)(script.props);\n                  });\n                } // handle redirect on client-transition\n\n\n                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                  _context2.next = 149;\n                  break;\n                }\n\n                // Use the destination from redirect without adding locale\n                options.locale = false;\n                destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n                // client-navigation if it is falling back to hard navigation if\n                // it's not\n\n                if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                  _context2.next = 147;\n                  break;\n                }\n\n                parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;\n                return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n              case 147:\n                handleHardNavigation({\n                  url: destination,\n                  router: this\n                });\n                return _context2.abrupt(\"return\", new Promise(function () {}));\n\n              case 149:\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                _context2.prev = 151;\n                _context2.next = 154;\n                return this.fetchComponent(\"/404\");\n\n              case 154:\n                notFoundRoute = \"/404\";\n                _context2.next = 160;\n                break;\n\n              case 157:\n                _context2.prev = 157;\n                _context2.t3 = _context2[\"catch\"](151);\n                notFoundRoute = \"/_error\";\n\n              case 160:\n                _context2.next = 162;\n                return this.getRouteInfo({\n                  route: notFoundRoute,\n                  pathname: notFoundRoute,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isNotFound: true\n                });\n\n              case 162:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 165;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on /404\");\n\n              case 165:\n                if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                // shallow routing is only allowed for same page URL changes.\n                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n                resetScroll = shouldScroll ? {\n                  x: 0,\n                  y: 0\n                } : null;\n                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n                upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                  route: route,\n                  pathname: pathname,\n                  query: query,\n                  asPath: cleanedAs,\n                  isFallback: false\n                }); // When the page being rendered is the 404 page, we should only update the\n                // query parameters. Route changes here might add the basePath when it\n                // wasn't originally present. This is also why this block is before the\n                // below `changeState` call which updates the browser's history (changing\n                // the URL).\n\n                if (!(isQueryUpdating && isErrorRoute)) {\n                  _context2.next = 188;\n                  break;\n                }\n\n                _context2.next = 174;\n                return this.getRouteInfo({\n                  route: this.pathname,\n                  pathname: this.pathname,\n                  query: query,\n                  as: as,\n                  resolvedAs: resolvedAs,\n                  routeProps: {\n                    shallow: false\n                  },\n                  locale: nextState.locale,\n                  isPreview: nextState.isPreview,\n                  isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n\n              case 174:\n                routeInfo = _context2.sent;\n\n                if (!(\"type\" in routeInfo)) {\n                  _context2.next = 177;\n                  break;\n                }\n\n                throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n              case 177:\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                  // ensure statusCode is still correct for static 500 page\n                  // when updating query information\n                  routeInfo.props.pageProps.statusCode = 500;\n                }\n\n                _context2.prev = 178;\n                _context2.next = 181;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 181:\n                _context2.next = 187;\n                break;\n\n              case 183:\n                _context2.prev = 183;\n                _context2.t4 = _context2[\"catch\"](178);\n\n                if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                  Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n                }\n\n                throw _context2.t4;\n\n              case 187:\n                return _context2.abrupt(\"return\", true);\n\n              case 188:\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n\n                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n                if (canSkipUpdating) {\n                  _context2.next = 211;\n                  break;\n                }\n\n                _context2.prev = 192;\n                _context2.next = 195;\n                return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n              case 195:\n                _context2.next = 204;\n                break;\n\n              case 197:\n                _context2.prev = 197;\n                _context2.t5 = _context2[\"catch\"](192);\n\n                if (!_context2.t5.cancelled) {\n                  _context2.next = 203;\n                  break;\n                }\n\n                routeInfo.error = routeInfo.error || _context2.t5;\n                _context2.next = 204;\n                break;\n\n              case 203:\n                throw _context2.t5;\n\n              case 204:\n                if (!routeInfo.error) {\n                  _context2.next = 207;\n                  break;\n                }\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                }\n\n                throw routeInfo.error;\n\n              case 207:\n                if (false) {}\n\n                if (!isQueryUpdating) {\n                  Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                } // A hash mark # is the optional last part of a URL\n\n\n                hashRegex = /#.+$/;\n\n                if (shouldScroll && hashRegex.test(as)) {\n                  this.scrollToHash(as);\n                }\n\n              case 211:\n                return _context2.abrupt(\"return\", true);\n\n              case 214:\n                _context2.prev = 214;\n                _context2.t6 = _context2[\"catch\"](121);\n\n                if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                  _context2.next = 218;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 218:\n                throw _context2.t6;\n\n              case 219:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                console.error(err);\n\n                if (!err.cancelled) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw err;\n\n              case 3:\n                if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                }); // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n\n                throw buildCancellationError();\n\n              case 7:\n                _context3.prev = 7;\n                _context3.next = 10;\n                return this.fetchComponent(\"/_error\");\n\n              case 10:\n                _yield$this$fetchComp = _context3.sent;\n                Component = _yield$this$fetchComp.page;\n                styleSheets = _yield$this$fetchComp.styleSheets;\n                routeInfo = {\n                  props: props,\n                  Component: Component,\n                  styleSheets: styleSheets,\n                  err: err,\n                  error: err\n                };\n\n                if (routeInfo.props) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.prev = 15;\n                _context3.next = 18;\n                return this.getInitialProps(Component, {\n                  err: err,\n                  pathname: pathname,\n                  query: query\n                });\n\n              case 18:\n                routeInfo.props = _context3.sent;\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](15);\n                console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n                routeInfo.props = {};\n\n              case 25:\n                return _context3.abrupt(\"return\", routeInfo);\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](7);\n                return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n              case 31:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require2, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData, props, cacheKey;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                /**\n                * This `route` binding can change if there's a rewrite\n                * so we keep a reference to the original requested route\n                * so we can store the cache for it and avoid re-requesting every time\n                * for shallow routing purposes.\n                */\n\n                route = requestedRoute;\n                _context5.prev = 2;\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", existingInfo);\n\n              case 7:\n                if (hasMiddleware) {\n                  existingInfo = undefined;\n                }\n\n                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n                isBackground = isQueryUpdating;\n                fetchNextDataParams = {\n                  dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                      pathname: pathname,\n                      query: query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale: locale\n                  }),\n                  hasMiddleware: true,\n                  isServerRender: this.isSsr,\n                  parseJSON: true,\n                  inflightCache: isBackground ? this.sbc : this.sdc,\n                  persistCache: !isPreview,\n                  isPrefetch: false,\n                  unstable_skipClientCache: unstable_skipClientCache,\n                  isBackground: isBackground\n                };\n\n                if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                _context5.t0 = null;\n                _context5.next = 18;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData(fetchNextDataParams);\n                  },\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale,\n                  router: this\n                })[\"catch\"](function (err) {\n                  // we don't hard error during query updating\n                  // as it's un-necessary and doesn't need to be fatal\n                  // unless it is a fallback route and the props can't\n                  // be loaded\n                  if (isQueryUpdating) {\n                    return null;\n                  }\n\n                  throw err;\n                });\n\n              case 17:\n                _context5.t0 = _context5.sent;\n\n              case 18:\n                data = _context5.t0;\n\n                // when rendering error routes we don't apply middleware\n                // effects\n                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                  data.effect = undefined;\n                }\n\n                if (isQueryUpdating) {\n                  if (!data) {\n                    data = {\n                      json: self.__NEXT_DATA__.props\n                    };\n                  } else {\n                    data.json = self.__NEXT_DATA__.props;\n                  }\n                }\n\n                handleCancelled();\n\n                if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", data.effect);\n\n              case 24:\n                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                _context5.next = 28;\n                return this.pageLoader.getPageList();\n\n              case 28:\n                pages = _context5.sent;\n\n                if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                route = resolvedRoute;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n                existingInfo = this.components[route];\n\n                if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                  _context5.next = 37;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                  route: route\n                }));\n\n              case 37:\n                if (!(0, _isapiroute.isAPIRoute)(route)) {\n                  _context5.next = 40;\n                  break;\n                }\n\n                handleHardNavigation({\n                  url: as,\n                  router: this\n                });\n                return _context5.abrupt(\"return\", new Promise(function () {}));\n\n              case 40:\n                _context5.t1 = cachedRouteInfo;\n\n                if (_context5.t1) {\n                  _context5.next = 45;\n                  break;\n                }\n\n                _context5.next = 44;\n                return this.fetchComponent(route).then(function (res) {\n                  return {\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                  };\n                });\n\n              case 44:\n                _context5.t1 = _context5.sent;\n\n              case 45:\n                routeInfo = _context5.t1;\n\n                if (false) {}\n\n                _require2 = __webpack_require__(/*! next/dist/compiled/react-is */ \"../../node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require2.isValidElementType;\n\n                if (isValidElementType(routeInfo.Component)) {\n                  _context5.next = 50;\n                  break;\n                }\n\n                throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n              case 50:\n                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n                // we clear the cache to fetch full response\n\n                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                  delete this.sdc[data.dataHref];\n                }\n\n                _context5.next = 55;\n                return this._getData( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                  var dataHref, fetched;\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!shouldFetchData) {\n                            _context4.next = 8;\n                            break;\n                          }\n\n                          if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                            _context4.next = 3;\n                            break;\n                          }\n\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                          });\n\n                        case 3:\n                          dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                            href: (0, _formaturl.formatWithValidation)({\n                              pathname: pathname,\n                              query: query\n                            }),\n                            asPath: resolvedAs,\n                            locale: locale\n                          });\n                          _context4.next = 6;\n                          return fetchNextData({\n                            dataHref: dataHref,\n                            isServerRender: _this2.isSsr,\n                            parseJSON: true,\n                            inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache: unstable_skipClientCache\n                          });\n\n                        case 6:\n                          fetched = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            cacheKey: fetched.cacheKey,\n                            props: fetched.json || {}\n                          });\n\n                        case 8:\n                          _context4.t0 = {};\n                          _context4.next = 11;\n                          return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                          {\n                            pathname: pathname,\n                            query: query,\n                            asPath: as,\n                            locale: locale,\n                            locales: _this2.locales,\n                            defaultLocale: _this2.defaultLocale\n                          });\n\n                        case 11:\n                          _context4.t1 = _context4.sent;\n                          return _context4.abrupt(\"return\", {\n                            headers: _context4.t0,\n                            props: _context4.t1\n                          });\n\n                        case 13:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                })));\n\n              case 55:\n                _yield$this$_getData = _context5.sent;\n                props = _yield$this$_getData.props;\n                cacheKey = _yield$this$_getData.cacheKey;\n\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                  delete this.sdc[cacheKey];\n                } // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n\n\n                if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                this.components[route] = routeInfo;\n                return _context5.abrupt(\"return\", routeInfo);\n\n              case 69:\n                _context5.prev = 69;\n                _context5.t2 = _context5[\"catch\"](2);\n                return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n              case 72:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (asPath === void 0) asPath = url;\n                if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n                if (false) {}\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                urlPathname = parsed.pathname;\n                pathname = parsed.pathname, query = parsed.query;\n                originalPathname = pathname;\n\n                if (false) {}\n\n                _context6.next = 13;\n                return this.pageLoader.getPageList();\n\n              case 13:\n                pages = _context6.sent;\n                resolvedAs = asPath;\n                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n                _context6.next = 18;\n                return _matchesMiddleware({\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 18:\n                isMiddlewareMatch = _context6.sent;\n\n                if (true) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 22;\n                return (0, _routeloader.getClientBuildManifest)();\n\n              case 22:\n                _yield = _context6.sent;\n                rewrites = _yield.__rewrites;\n                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                  return resolveDynamicRoute(p, pages);\n                }, this.locales);\n\n                if (!rewritesResult.externalDest) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 27:\n                if (!isMiddlewareMatch) {\n                  resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n                }\n\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                  // if this directly matches a page we need to update the href to\n                  // allow the correct page chunk to be loaded\n                  pathname = rewritesResult.resolvedHref;\n                  parsed.pathname = pathname;\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n              case 29:\n                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                  pathname = parsed.pathname;\n                  parsed.pathname = pathname;\n                  Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                  if (!isMiddlewareMatch) {\n                    url = (0, _formaturl.formatWithValidation)(parsed);\n                  }\n                }\n\n                if (true) {\n                  _context6.next = 35;\n                  break;\n                }\n\n                _context6.t0 = null;\n                _context6.next = 38;\n                break;\n\n              case 35:\n                _context6.next = 37;\n                return withMiddlewareEffects({\n                  fetchData: function fetchData() {\n                    return fetchNextData({\n                      dataHref: _this3.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: originalPathname,\n                          query: query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale: locale\n                      }),\n                      hasMiddleware: true,\n                      isServerRender: _this3.isSsr,\n                      parseJSON: true,\n                      inflightCache: _this3.sdc,\n                      persistCache: !_this3.isPreview,\n                      isPrefetch: true\n                    });\n                  },\n                  asPath: asPath,\n                  locale: locale,\n                  router: this\n                });\n\n              case 37:\n                _context6.t0 = _context6.sent;\n\n              case 38:\n                data = _context6.t0;\n\n                /**\n                * If there was a rewrite we apply the effects of the rewrite on the\n                * current parameters for the prefetch.\n                */\n                if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                  parsed.pathname = data.effect.resolvedHref;\n                  pathname = data.effect.resolvedHref;\n                  query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                  resolvedAs = data.effect.parsedAs.pathname;\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n                /**\n                * If there is a redirect to an external destination then we don't have\n                * to prefetch content as it will be unused.\n                */\n\n\n                if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                  _context6.next = 42;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 42:\n                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                _context6.next = 45;\n                return this._bfl(asPath, resolvedAs, options.locale, true);\n\n              case 45:\n                if (!_context6.sent) {\n                  _context6.next = 47;\n                  break;\n                }\n\n                this.components[urlPathname] = {\n                  __appRouter: true\n                };\n\n              case 47:\n                _context6.next = 49;\n                return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                  return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                      href: url,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                  }).then(function () {\n                    return false;\n                  })[\"catch\"](function () {\n                    return false;\n                  }) : false;\n                }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n              case 49:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                handleCancelled = getCancelledHandler({\n                  route: route,\n                  router: this\n                });\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.pageLoader.loadPage(route);\n\n              case 4:\n                componentResult = _context7.sent;\n                handleCancelled();\n                return _context7.abrupt(\"return\", componentResult);\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](1);\n                handleCancelled();\n                throw _context7.t0;\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0EsTUFBTUMsQ0FBTjs7QUFLQSxTQUFTRyxPQUFULENBQWlCQyxNQUFqQixFQUF5QkMsR0FBekIsRUFBOEI7RUFDMUIsS0FBSSxJQUFJQyxJQUFSLElBQWdCRCxHQUFoQjtJQUFvQlQsTUFBTSxDQUFDQyxjQUFQLENBQXNCTyxNQUF0QixFQUE4QkUsSUFBOUIsRUFBb0M7TUFDcERDLFVBQVUsRUFBRSxJQUR3QztNQUVwREMsR0FBRyxFQUFFSCxHQUFHLENBQUNDLElBQUQ7SUFGNEMsQ0FBcEM7RUFBcEI7QUFJSDs7QUFDREgsT0FBTyxDQUFDTCxPQUFELEVBQVU7RUFDYixXQUFTLG9CQUFXO0lBQ2hCLE9BQU9XLE1BQVA7RUFDSCxDQUhZO0VBSWJSLGlCQUFpQixFQUFFLDZCQUFXO0lBQzFCLE9BQU9BLGtCQUFQO0VBQ0gsQ0FOWTtFQU9iQyxTQUFTLEVBQUUscUJBQVc7SUFDbEIsT0FBT0EsVUFBUDtFQUNIO0FBVFksQ0FBVixDQUFQOztBQVdBLElBQU1RLHdCQUF3QixHQUFHQyxtQkFBTyxDQUFDLGdIQUFELENBQXhDOztBQUNBLElBQU1DLHlCQUF5QixHQUFHRCxtQkFBTyxDQUFDLGtIQUFELENBQXpDOztBQUNBLElBQU1FLG9CQUFvQixHQUFHRixtQkFBTyxDQUFDLG9IQUFELENBQXBDOztBQUNBLElBQU1HLFlBQVksR0FBR0gsbUJBQU8sQ0FBQyx5RkFBRCxDQUE1Qjs7QUFDQSxJQUFNSSxPQUFPLEdBQUdKLG1CQUFPLENBQUMsNkVBQUQsQ0FBdkI7O0FBQ0EsSUFBTUssUUFBUSxHQUFHLGFBQWNKLHlCQUF5QixDQUFDSyxDQUExQixDQUE0Qk4sbUJBQU8sQ0FBQywyRUFBRCxDQUFuQyxDQUEvQjs7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Tl9FLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzEwZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBudWxsLFxuICAgIGNyZWF0ZUtleTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlcjtcbiAgICB9LFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNNaWRkbGV3YXJlO1xuICAgIH0sXG4gICAgY3JlYXRlS2V5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVtb3ZldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IF9yb3V0ZWxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xuY29uc3QgX3NjcmlwdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvc2NyaXB0XCIpO1xuY29uc3QgX2lzZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcbmNvbnN0IF9kZW5vcm1hbGl6ZXBhZ2VwYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG5jb25zdCBfbm9ybWFsaXplbG9jYWxlcGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbmNvbnN0IF9taXR0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9wYXJzZXJlbGF0aXZldXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xuY29uc3QgX3Jlc29sdmVyZXdyaXRlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG5jb25zdCBfcm91dGVtYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbmNvbnN0IF9yb3V0ZXJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9kZXRlY3Rkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXBhdGhcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmViYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShvcHRpb25zLmFzUGF0aCk7XG4gICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXNQYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWU7XG4gICAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpKTtcbiAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pPT5uZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKSk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfZGVub3JtYWxpemVwYWdlcGF0aC5kZW5vcm1hbGl6ZVBhZ2VQYXRoKShwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSBcIi80MDRcIiB8fCBjbGVhblBhdGhuYW1lID09PSBcIi9fZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZXdyaXRlXCIpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLW1hdGNoZWQtcGF0aFwiKTtcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tYXRjaGVkLXBhdGhcIik7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIl9fbmV4dF9kYXRhX2NhdGNoYWxsXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi9fZXJyb3JcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiLzQwNFwiKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gcGFyYW07XG4gICAgICAgICAgICAgICAgbGV0IGFzID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkoYXMpIHx8ICFyZXdyaXRlSGVhZGVyICYmIHBhZ2VzLmluY2x1ZGVzKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTb3VyY2UgPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHNvdXJjZSkucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKFwiU1NHX0RBVEFfTk9UX0ZPVU5EXCIpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgXCJ4LW5leHRqcy1kYXRhXCI6IFwiMVwiXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciBfcGFyYW1zX21ldGhvZDtcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PntcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XG4gICAgICAgICAgICAgICAgcHVycG9zZTogXCJwcmVmZXRjaFwiXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICBcIngtbWlkZGxld2FyZS1wcmVmZXRjaFwiOiBcIjFcIlxuICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgIG1ldGhvZDogKF9wYXJhbXNfbWV0aG9kID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gX3BhcmFtc19tZXRob2QgOiBcIkdFVFwiXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJ5VG9QYXJzZUFzSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RyeVRvUGFyc2VBc0pTT04gPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RyeVRvUGFyc2VBc0pTT04ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzXCIpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIGNocm9tZVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgLy8gZmlyZWZveFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIiB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIHNhbWVcbiAgICAvLyBVUkwgYXMgdGhpcyBjYW4gZW5kIHVwIHdpdGggYW4gaW5maW5pdGUgcmVmcmVzaFxuICAgIGlmICh1cmwgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMIFwiICsgdXJsICsgXCIgXCIgKyBsb2NhdGlvbi5ocmVmKTtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG59XG5jb25zdCBnZXRDYW5jZWxsZWRIYW5kbGVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IHJvdXRlICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSwgc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjdXJBcyBvZiBbXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgXSl7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc05vU2xhc2gsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNOb1NsYXNoICE9PSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTCh0aGlzLmFzUGF0aCwgXCJodHRwOi8vblwiKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX3MsIF90aGlzX19iZmxfczE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljID0gbWF0Y2hlc0JmbFN0YXRpYyB8fCAhISgoX3RoaXNfX2JmbF9zID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MuaGFzKGFzTm9TbGFzaCkpIHx8ICEhKChfdGhpc19fYmZsX3MxID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MxLmhhcyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5oYXMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbER5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0JmbFN0YXRpYyB8fCBtYXRjaGVzQmZsRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xuICAgICAgICB2YXIgX3RoaXNfY29tcG9uZW50c19wYXRobmFtZTtcbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkodXJsKSkge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gb3B0aW9ucy5faCA9PT0gMTtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hvdWxkUmVzb2x2ZUhyZWYgPSBpc1F1ZXJ5VXBkYXRpbmcgfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKSh1cmwpLnBhdGhuYW1lID09PSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZVxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICAgICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IHRoaXMuaXNSZWFkeSAhPT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNTc3IgPSB0aGlzLmlzU3NyO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHVybCkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKSh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX2xvY2FsZXM7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChfdGhpc19sb2NhbGVzID0gdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfbG9jYWxlcy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSAoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKHRoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIHRoaXMuaXNMb2NhbGVEb21haW4gJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBcIiArIChkZXRlY3RlZERvbWFpbi5odHRwID8gXCJcIiA6IFwic1wiKSArIFwiOi8vXCIgKyBkZXRlY3RlZERvbWFpbi5kb21haW4gKyAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShcIlwiICsgKG5leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyBcIlwiIDogXCIvXCIgKyBuZXh0U3RhdGUubG9jYWxlKSArIChhc05vQmFzZVBhdGggPT09IFwiL1wiID8gXCJcIiA6IGFzTm9CYXNlUGF0aCkgfHwgXCIvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwicm91dGVDaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAsIHNjcm9sbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGMoKTtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgY29uc3QgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICgoX3RoaXNfY29tcG9uZW50c19wYXRobmFtZSA9IHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lLl9fYXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwicmVwbGFjZVN0YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKFwiL1wiKSAmJiAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVSZXdyaXRlID0gISEocGFyc2VkQXNQYXRobmFtZSAmJiByb3V0ZSAhPT0gcGFyc2VkQXNQYXRobmFtZSAmJiAoISgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkgfHwgISgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKSkocGFyc2VkQXNQYXRobmFtZSkpKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9ICFvcHRpb25zLnNoYWxsb3cgJiYgYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgc2hvdWxkUmVzb2x2ZUhyZWYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBxdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBocmVmOiBcIicgKyB1cmwgKyAnXCIgYW5kIGFzOiBcIicgKyBhcyArICdcIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXMnICsgXCJcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xuICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVhcy5pbnRlcnBvbGF0ZUFzKShyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV0gJiYgIXJvdXRlUmVnZXguZ3JvdXBzW3BhcmFtXS5vcHRpb25hbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIkludGVycG9sYXRpbmcgaHJlZlwiIDogXCJNaXNtYXRjaGluZyBgYXNgIGFuZCBgaHJlZmBcIikgKyBcIiBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBcIiArIChcInRoZSBwYXJhbXM6IFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIiBpbiB0aGUgYGhyZWZgJ3MgYHF1ZXJ5YFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiVGhlIHByb3ZpZGVkIGBocmVmYCAoXCIgKyB1cmwgKyBcIikgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIikgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBcIiA6IFwiVGhlIHByb3ZpZGVkIGBhc2AgdmFsdWUgKFwiICsgYXNQYXRobmFtZSArIFwiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgYGhyZWZgIHZhbHVlIChcIiArIHJvdXRlICsgXCIpLiBcIikgKyAoXCJSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL1wiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJocmVmLWludGVycG9sYXRpb24tZmFpbGVkXCIgOiBcImluY29tcGF0aWJsZS1ocmVmLWFzXCIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IHRoaXMucGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xuICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiBpc01pZGRsZXdhcmVNYXRjaCxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCBcInJlc29sdmVkQXNcIiBpbiByb3V0ZUluZm8gPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6IHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJyb3V0ZVwiIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlO1xuICAgICAgICAgICAgICAgIHJvdXRlID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocmV3cml0ZUFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZUFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHJld3JpdGVBcywgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkobmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGN1clJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSBcInJlZGlyZWN0LWludGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcm91dGVJbmZvLkNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCkoc2NyaXB0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgaWYgKChyb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUCkgJiYgcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKFwiL1wiKSAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvX2Vycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlSW5mb19yb3V0ZSA9IHJvdXRlSW5mby5yb3V0ZSkgIT0gbnVsbCA/IF9yb3V0ZUluZm9fcm91dGUgOiByb3V0ZSk7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSwgX3JvdXRlSW5mb19wcm9wczE7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICBcIlwiLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogXCIsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgXCJcIiksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUgLCBwYXRobmFtZSAsIHF1ZXJ5ICwgYXMgLCByZXNvbHZlZEFzICwgcm91dGVQcm9wcyAsIGxvY2FsZSAsIGhhc01pZGRsZXdhcmUgLCBpc1ByZXZpZXcgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgLCBpc1F1ZXJ5VXBkYXRpbmcgLCBpc01pZGRsZXdhcmVSZXdyaXRlICwgaXNOb3RGb3VuZCAgfSA9IHBhcmFtO1xuICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9kYXRhX2VmZmVjdCwgX2RhdGFfZWZmZWN0MSwgX2RhdGFfZWZmZWN0MiwgX2RhdGFfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgIShcImluaXRpYWxcIiBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmc7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdCA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWludGVybmFsXCIgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNhcGlyb3V0ZS5pc0FQSVJvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShyb3V0ZUluZm8uQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgcGF0aG5hbWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9yZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1za2lwXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1A7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLVNTRyBwcmVmZXRjaGVzIHRoYXQgYmFpbGVkIGJlZm9yZSBzZW5kaW5nIGRhdGFcbiAgICAgICAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSB0byBmZXRjaCBmdWxsIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2RhdGEuZGF0YUhyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyAsIGNhY2hlS2V5ICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiY1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdChcIiNcIik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoXCIjXCIpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSBcIlwiIHx8IGhhc2ggPT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PndpbmRvdy5zY3JvbGxUbygwLCAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjb2RlIGhhc2ggdG8gbWFrZSBub24tbGF0aW4gYW5jaG9yIHdvcmtzLlxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmF3SGFzaCk7XG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT5pZEVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9Pm5hbWVFbC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc1BhdGggPT09IHZvaWQgMCkgYXNQYXRoID0gdXJsO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICgwLCBfaXNib3QuaXNCb3QpKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAgICAgICAvLyBwcmVmZXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG9jYWxlIHx8IHVuZGVmaW5lZCA6IHRoaXMubG9jYWxlO1xuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhcnNlZC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXJzZWQucGF0aG5hbWUpKSgoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzUGF0aCkucGF0aG5hbWUpIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09IFwic3RyaWN0XCIgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZXdyaXRlXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBfX2FwcFJvdXRlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXG4gICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpLmNhdGNoKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyBcImxvYWRQYWdlXCIgOiBcInByZWZldGNoXCJdKHJvdXRlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgLy8gRG8gbm90IGNhY2hlIFJTQyBmbGlnaHQgcmVzcG9uc2Ugc2luY2UgaXQncyBub3QgYSBzdGF0aWMgcmVzb3VyY2VcbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlSlNPTjogZmFsc2UsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZVxuICAgICAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHRleHQgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl07XG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubG9hZEdldEluaXRpYWxQcm9wcykoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcm91dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xuICAgIH1cbiAgICBnZXQgcXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIH1cbiAgICBnZXQgYXNQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGg7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGlzRmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2s7XG4gICAgfVxuICAgIGdldCBpc1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlldztcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMgLCBwYWdlTG9hZGVyICwgQXBwICwgd3JhcEFwcCAsIENvbXBvbmVudCAsIGVyciAsIHN1YnNjcmlwdGlvbiAsIGlzRmFsbGJhY2sgLCBsb2NhbGUgLCBsb2NhbGVzICwgZGVmYXVsdExvY2FsZSAsIGRvbWFpbkxvY2FsZXMgLCBpc1ByZXZpZXcgIH0pe1xuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGtleSAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLmFzUGF0aCkgJiYgcGF0aG5hbWUgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICAgICAgICAgIF9oOiAwXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBjb25zdCB7IEJsb29tRmlsdGVyICB9ID0gcmVxdWlyZShcIi4uLy4uL2xpYi9ibG9vbS1maWx0ZXJcIik7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5zaXplLCBzdGF0aWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5zaXplLCBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgICAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCBtYXRjaGVzID8gYXNQYXRoIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSwgYXNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuKCgpPT57XG4gICAgUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiY3JlYXRlS2V5IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIl9yb3V0ZWxvYWRlciIsIl9zY3JpcHQiLCJfaXNlcnJvciIsIl8iLCJfZGVub3JtYWxpemVwYWdlcGF0aCIsIl9ub3JtYWxpemVsb2NhbGVwYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNkeW5hbWljIiwiX3BhcnNlcmVsYXRpdmV1cmwiLCJfcmVzb2x2ZXJld3JpdGVzIiwiX3JvdXRlbWF0Y2hlciIsIl9yb3V0ZXJlZ2V4IiwiX2Zvcm1hdHVybCIsIl9kZXRlY3Rkb21haW5sb2NhbGUiLCJfcGFyc2VwYXRoIiwiX2FkZGxvY2FsZSIsIl9yZW1vdmVsb2NhbGUiLCJfcmVtb3ZlYmFzZXBhdGgiLCJfYWRkYmFzZXBhdGgiLCJfaGFzYmFzZXBhdGgiLCJfaXNhcGlyb3V0ZSIsIl9nZXRuZXh0cGF0aG5hbWVpbmZvIiwiX2Zvcm1hdG5leHRwYXRobmFtZWluZm8iLCJfY29tcGFyZXN0YXRlcyIsIl9pc2xvY2FsdXJsIiwiX2lzYm90IiwiX29taXQiLCJfcmVzb2x2ZWhyZWYiLCJfaW50ZXJwb2xhdGVhcyIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsIm1hdGNoZXJzIiwicGFyc2VQYXRoIiwiYXNQYXRoIiwiYXNQYXRobmFtZSIsInBhdGhuYW1lIiwiY2xlYW5lZEFzIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJzb21lIiwibSIsIlJlZ0V4cCIsInJlZ2V4cCIsInRlc3QiLCJzdHJpcE9yaWdpbiIsInVybCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZUhyZWYiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwiaHJlZldhc0Fic29sdXRlIiwiYXNXYXNBYnNvbHV0ZSIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsImluY2x1ZGVzIiwicGFnZSIsImlzRHluYW1pY1JvdXRlIiwiZ2V0Um91dGVSZWdleCIsInJlIiwiZ2V0TWlkZGxld2FyZURhdGEiLCJzb3VyY2UiLCJyZXNwb25zZSIsIm5leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJsb2NhbGVzIiwidHJhaWxpbmdTbGFzaCIsIkJvb2xlYW4iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwicmV3cml0ZUhlYWRlciIsImhlYWRlcnMiLCJyZXdyaXRlVGFyZ2V0IiwibWF0Y2hlZFBhdGgiLCJfX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUiLCJwYXJzZWRSZXdyaXRlVGFyZ2V0IiwicGFyc2VSZWxhdGl2ZVVybCIsInBhdGhuYW1lSW5mbyIsImdldE5leHRQYXRobmFtZUluZm8iLCJwYXJzZURhdGEiLCJmc1BhdGhuYW1lIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsInBhcmFtIiwicmV3cml0ZXMiLCJfX3Jld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJkYXRhSHJlZiIsImVmZmVjdCIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiX3BhcmFtc19tZXRob2QiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImVyciIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsInJvdXRlIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3Iiwic2RjIiwic2JjIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJfa2V5Iiwib25Qb3BTdGF0ZSIsImUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJnZXRVUkwiLCJfX05BIiwicmVsb2FkIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwia2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJpc1NzciIsIl9icHMiLCJjaGFuZ2UiLCJzaGFsbG93IiwiX3NoYWxsb3ciLCJfaCIsImNvbXBvbmVudHMiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInN0eWxlU2hlZXRzIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQiLCJCbG9vbUZpbHRlciIsInN0YXRpY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIiLCJoYXNoZXMiLCJfYmZsX3MiLCJzaXplIiwiX2JmbF9kIiwiZXZlbnRzIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJzdWIiLCJfd3JhcEFwcCIsImlzTG9jYWxlRG9tYWluIiwiaXNSZWFkeSIsImdzc3AiLCJnaXAiLCJhcHBHaXAiLCJnc3AiLCJzZWFyY2giLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiaG9zdG5hbWUiLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsImJhY2siLCJmb3J3YXJkIiwic2tpcE5hdmlnYXRlIiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwiY3VyQXMiLCJhc05vU2xhc2giLCJhc05vU2xhc2hMb2NhbGUiLCJfdGhpc19fYmZsX3MiLCJoYXMiLCJfdGhpc19fYmZsX3MxIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsIl90aGlzX19iZmxfZCIsImlzTG9jYWxVUkwiLCJpc1F1ZXJ5VXBkYXRpbmciLCJfYmZsIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImRpZE5hdmlnYXRlIiwiX3RoaXNfbG9jYWxlcyIsImRldGVjdGVkRG9tYWluIiwiZG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsImxvY2FsZUNoYW5nZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsInBhcnNlZCIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJfX2FwcFJvdXRlciIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsIm9wdGlvbmFsIiwiY29uc29sZSIsIndhcm4iLCJvbWl0IiwiaXNFcnJvclJvdXRlIiwiZ2V0Um91dGVJbmZvIiwicm91dGVJbmZvIiwiY2xlYW5lZFBhcnNlZFBhdGhuYW1lIiwiZm9yRWFjaCIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50IiwidW5zdGFibGVfc2NyaXB0TG9hZGVyIiwic2NyaXB0cyIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwicGFyc2VkSHJlZiIsIl9fTl9QUkVWSUVXIiwiZmV0Y2hDb21wb25lbnQiLCJub3RGb3VuZFJvdXRlIiwiaXNOb3RGb3VuZCIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyIsInN0YXR1c0NvZGUiLCJfcm91dGVJbmZvX3Byb3BzIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsIl9yb3V0ZUluZm9fcm91dGUiLCJzaG91bGRTY3JvbGwiLCJfb3B0aW9uc19zY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYXNoUmVnZXgiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwiZ2V0SW5pdGlhbFByb3BzIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJyZXF1ZXN0ZWRSb3V0ZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwiX2RhdGFfZWZmZWN0IiwiX2RhdGFfZWZmZWN0MSIsIl9kYXRhX2VmZmVjdDIiLCJyZXNvbHZlZFJvdXRlIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwiX2RhdGFfcmVzcG9uc2UiLCJzaG91bGRGZXRjaERhdGEiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJsb2FkUGFnZSIsImNvbXBvbmVudFJlc3VsdCIsImZuIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});